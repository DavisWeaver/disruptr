expected_np_old <- c(15.7, -4.8, Inf, -0.94, -2.23, -1.38)
names(expected_np_old) <- seeds
v_check <- seeds[5]
g <- igraph::induced_subgraph(g, seeds)
expected_np_diff <- c(0.0, 6.21, NaN, 0.082, 0.0)
names(expected_np_diff) <- seeds[seeds != v_check]
v_rm  = v_check
state_function = calc_np_all2
neighbors_only = TRUE
exp = toy_exp
#grab all vertices of g
vertices <- as.character(names(igraph::V(g)))
#
if(neighbors_only == TRUE) {
neighbors <-
lapply(v_rm,
get_neighbors, g = g)
#so we need neighbors of neighbors of v_rm as well
names(neighbors) <- v_rm
}
#
#
neighbors_all <- lapply(vertices,
get_neighbors, g = g)
names(neighbors_all) <- vertices
out_mat <- Matrix::Matrix(0, nrow = length(igraph::V(g)), ncol = length(v_rm),
sparse = TRUE)
row.names(out_mat) <- vertices
for(i in v_rm) {
#define v to be either all nodes or neighbors of v_rm
if(neighbors_only == TRUE) {
v <- neighbors[[i]] #get neighbors
v <- as.character(names(igraph::V(g)[v]))
} else {
v = as.character(names(igraph::V(g)))
}
g_new <- igraph::delete_vertices(g = g, v = i)
#calculate state vector for original graph
s_old <- state_function(exp = exp, g = g, v=c(v,i), neighbors = neighbors_all) #calculate network potential for the deleted note in addition to the neighbors
delete_node <- c(i = 0)
s_new <- c(state_function(exp = exp, g = g_new, v = v, neighbors = neighbors_all), delete_node) #calc new network potential for the neighbors + 0 for the deleted node
s_new <- s_new[names(s_old)]
s_diff <- s_new-s_old #calculate the diff and save
out_mat[,i] <- s_diff
}
s_diff
s_old
s_new
delete_node
delete_node <- c(v_rm = 0)
delete_node
delete_node <- c(get(i) = 0)
get(i)
eval(i)
delete_node <- c(eval(i) = 0)
delete_node <- c(0 = i)
#create a 0 value deleted node to add on
delete_node <- 0
names(delete_node) <- i
delete_node
s_new <- c(state_function(exp = exp, g = g_new, v = v, neighbors = neighbors_all), delete_node) #calc new network potential for the neighbors + 0 for the deleted node
s_new <- s_new[names(s_old)]
s_diff <- s_new-s_old #calculate the diff and save
s_diff
s_new
s_old
out_mat[,i] <- s_diff
out_mat[,1]
i <- 1
out_mat[,i] <- s_diff
out_mat[,1]
col.names(out_mat) <- v_rm
colnames(out_mat) <- v_rm
calc_np_all2(exp = exp, g = g_new)
s_new
v = v
calc_np_all2(exp = exp, g = g_new, v =v)
calc_np_all2(exp = exp, g = g_new, v =v, neighbors = neighbors_all)
neighbors_all
neighbors <-
lapply(vertices,
get_neighbors, g = g)
names(neighbors) <- vertices
neighbors
#We don't need to do this with the new logical indexing - just set it to 0 for s_new
#g_new <- igraph::delete_vertices(g = g, v = v_rm[i])
#calculate state vector for original graph
s_old <- state_function(exp = exp, g = g, v=c(v,v_rm[i]), neighbors = neighbors_all) #calculate network potential for the deleted note in addition to the neighbors
s_new <- state_function(exp = exp, g = g, v = v, neighbors = neighbors_all) #calc new network potential for the neighbors + 0 for the deleted node
s_new
s_old
g <- g_new
#first add expression to the subgraph.
g <- add_expression(exp = exp, g = g)
vertices <- as.character(names(igraph::V(g))) #in most cases this will be the same as `v`
# remove any names of exp that are not in the graph.
exp <- exp[names(exp) %in% vertices]
# need to do the same thing for v (because sometimes there will be neighbors of a given node that aren't in the ppi)
# actually how is that even possible? leaving it in for now
v <- v[v %in% vertices]
#re-order exp to have the same order as vertices
exp <- exp[vertices]
exp
vertices
if(is.null(neighbors)) {
neighbors <-
lapply(vertices,
get_neighbors, g = g)
names(neighbors) <- vertices
} else {
neighbors <- neighbors[vertices] #index to make sure we don't have any list items we don't need and to make sure they are in the same order as exp and vertices
}
neighbors
#run cpp function to do the actual calculation on each node
np_vec <- fcalc_np_all(neighbors = neighbors, vertices = vertices, v = v, exp = exp)
np_vec
neighbors = NULL
if(is.null(neighbors)) {
neighbors <-
lapply(vertices,
get_neighbors, g = g)
names(neighbors) <- vertices
} else {
neighbors <- neighbors[vertices] #index to make sure we don't have any list items we don't need and to make sure they are in the same order as exp and vertices
}
neighbors
#g_new <- igraph::delete_vertices(g = g, v = v_rm[i])
exp_new <- exp
exp_new[v_rm[i]] <- 0
v)rn
v_rm
v_rm[1]
exp_new["JAG1"]
exp
exp_new
devtools::load_all()
devtools::load_all()
load(system.file("test_data/toy_graph.Rda", package = "disruptr"))
#np_all
seeds <- c("OLR1", "APP", "VAV2", "ITGAV", "JAG1", "APOH")
toy_exp <- c(4.9, 9.9, 1.0, 0.2, 7.5, 8.4)
names(toy_exp) <- seeds
expected_np_old <- c(15.7, -4.8, Inf, -0.94, -2.23, -1.38)
names(expected_np_old) <- seeds
v_check <- seeds[5]
g <- igraph::induced_subgraph(g, seeds)
expected_np_diff <- c(0.0, 6.21, NaN, 0.082, 0.0)
names(expected_np_diff) <- seeds[seeds != v_check]
v_rm = v_check
exp <- toy_exp
state_function = calc_np_all2
neighbors_only = TRUE
#grab all vertices of g
vertices <- as.character(names(igraph::V(g)))
#
if(neighbors_only == TRUE) {
neighbors <-
lapply(v_rm,
get_neighbors, g = g)
#so we need neighbors of neighbors of v_rm as well
names(neighbors) <- v_rm
}
#
#
neighbors_all <- lapply(vertices,
get_neighbors, g = g)
names(neighbors_all) <- vertices
out_mat <- Matrix::Matrix(0, nrow = length(igraph::V(g)), ncol = length(v_rm),
sparse = TRUE)
row.names(out_mat) <- vertices
colnames(out_mat) <- v_rm
for(i in 1:length(v_rm)) {
#define v to be either all nodes or neighbors of v_rm
if(neighbors_only == TRUE) {
v <- neighbors_all[[v_rm[i]]] #get neighbors
v <- as.character(names(igraph::V(g)[v]))
} else {
v <- as.character(names(igraph::V(g)))
}
#g_new <- igraph::delete_vertices(g = g, v = v_rm[i])
exp_new <- exp
exp_new[v_rm[i]] <- 0
#calculate state vector for original graph
s_old <- state_function(exp = exp, g = g, v=c(v,v_rm[i]), neighbors = neighbors_all) #calculate network potential for the deleted note in addition to the neighbors
#create a 0 value deleted node to add on
# delete_node <- 0
# names(delete_node) <- v_rm[i]
s_new <- state_function(exp = exp_new, g = g, v = v, neighbors = neighbors_all) #calc new network potential for the neighbors + 0 for the deleted node
s_new <- s_new[names(s_old)]
s_diff <- s_new-s_old #calculate the diff and save
out_mat[,i] <- s_diff
}
out_mat[,1]
np_diff <- node_repression(g, v_rm = v_check,
state_function = calc_np_all2, exp = toy_exp)
devtools::load_all()
np_diff <- node_repression(g, v_rm = v_check,
state_function = calc_np_all2, exp = toy_exp)
devtools::load_all()
load(system.file("test_data/toy_graph.Rda", package = "disruptr"))
#np_all
seeds <- c("OLR1", "APP", "VAV2", "ITGAV", "JAG1", "APOH")
toy_exp <- c(4.9, 9.9, 1.0, 0.2, 7.5, 8.4)
names(toy_exp) <- seeds
expected_np_old <- c(15.7, -4.8, Inf, -0.94, -2.23, -1.38)
names(expected_np_old) <- seeds
v_check <- seeds[5]
g <- igraph::induced_subgraph(g, seeds)
np_diff <- node_repression(g, v_rm = v_check,
state_function = calc_np_all2, exp = toy_exp)
v_rm = v_check
state_function = calc_np_all2
neigbors_only = TRUE
EXP = TOY_EXP
exp = toy_exp
#grab all vertices of g
vertices <- as.character(names(igraph::V(g)))
#Get a list of neighbors in the graph - this will speed things up a lot if we are suppressing tons of nodes simultaneously
neighbors_all <- lapply(vertices,
get_neighbors, g = g)
names(neighbors_all) <- vertices
out_mat <- Matrix::Matrix(0, nrow = length(igraph::V(g)), ncol = length(v_rm),
sparse = TRUE)
row.names(out_mat) <- vertices
colnames(out_mat) <- v_rm
for(i in 1:length(v_rm)) {
#define v to be either all nodes or neighbors of v_rm
if(neighbors_only == TRUE) {
v <- neighbors_all[[v_rm[i]]] #get neighbors
v <- as.character(names(igraph::V(g)[v]))
} else {
v <- as.character(names(igraph::V(g)))
}
#g_new <- igraph::delete_vertices(g = g, v = v_rm[i])
exp_new <- exp
exp_new[v_rm[i]] <- 0
#calculate state vector for original graph
s_old <- state_function(exp = exp, g = g, v=c(v,v_rm[i]), neighbors = neighbors_all) #calculate network potential for the deleted note in addition to the neighbors
#create a 0 value deleted node to add on
# delete_node <- 0
# names(delete_node) <- v_rm[i]
s_new <- state_function(exp = exp_new, g = g, v = v, neighbors = neighbors_all) #calc new network potential for the neighbors + 0 for the deleted node
s_new <- s_new[names(s_old)]
s_diff <- s_new-s_old #calculate the diff and save
out_mat[,i] <- s_diff
}
neighbors_only = TRUE
for(i in 1:length(v_rm)) {
#define v to be either all nodes or neighbors of v_rm
if(neighbors_only == TRUE) {
v <- neighbors_all[[v_rm[i]]] #get neighbors
v <- as.character(names(igraph::V(g)[v]))
} else {
v <- as.character(names(igraph::V(g)))
}
#g_new <- igraph::delete_vertices(g = g, v = v_rm[i])
exp_new <- exp
exp_new[v_rm[i]] <- 0
#calculate state vector for original graph
s_old <- state_function(exp = exp, g = g, v=c(v,v_rm[i]), neighbors = neighbors_all) #calculate network potential for the deleted note in addition to the neighbors
#create a 0 value deleted node to add on
# delete_node <- 0
# names(delete_node) <- v_rm[i]
s_new <- state_function(exp = exp_new, g = g, v = v, neighbors = neighbors_all) #calc new network potential for the neighbors + 0 for the deleted node
s_new <- s_new[names(s_old)]
s_diff <- s_new-s_old #calculate the diff and save
out_mat[,i] <- s_diff
}
exp
rm(exp)
exp
devtools::load_all()
load(system.file("test_data/toy_graph.Rda", package = "disruptr"))
#np_all
seeds <- c("OLR1", "APP", "VAV2", "ITGAV", "JAG1", "APOH")
toy_exp <- c(4.9, 9.9, 1.0, 0.2, 7.5, 8.4)
names(toy_exp) <- seeds
expected_np_old <- c(15.7, -4.8, Inf, -0.94, -2.23, -1.38)
names(expected_np_old) <- seeds
v_check <- seeds[5]
g <- igraph::induced_subgraph(g, seeds)
np_diff <- node_repression(g, v_rm = v_check, exp = toy_exp
state_function = calc_np_all2)
np_diff <- node_repression(g, v_rm = v_check, exp = toy_exp,
state_function = calc_np_all2)
np_diff
np_diff <- np_diff[,1]
expected_np_diff <- c(0.0, 6.21, 2.23, 0.082, 0.0)
names(expected_np_diff) <- seeds
expected_np_diff <- expected_np_diff[names(np_diff)]
test_that("node_repression produces expected results", {
expect_equal(np_diff,
expected_np_diff, tolerance = 0.1)
})
expected_np_diff
expected_np_diff <- c(0.0, 6.21, 2.23, 0.082, 0.0)
names(expected_np_diff) <- seeds
np_diff
seeds
expected_np_diff <- c(0.0, 6.21, 0.0, 0.082, 2.23, 0.0)
names(expected_np_diff) <- seeds
expected_np_diff <- expected_np_diff[names(np_diff)]
test_that("node_repression produces expected results", {
expect_equal(np_diff,
expected_np_diff, tolerance = 0.1)
})
devtools::test()
devtools::documetn()
devtools::document()
devtools::load_all()
devtools::install()
devtools::install()
devtools::install()
install.packages("dplyr")
install.packages("dplyr")
devtools::install()
source('~/miRNA_targeting/MiR_Analysis_Functions.R')
library(dplyr)
library(tidyr)
library(magrittr)
load('./data_files/final_df.Rda')
cache = "./data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load("./data_files/stjude_counts.Rda")
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
cache = "G:/My Drive/MIR_Combo_Targeting/code/miRNA_Targeting/data_files"
load(paste0(cache, "stjude_counts.Rda"))
cache = "G:/My Drive/MIR_Combo_Targeting/code/miRNA_Targeting/data_files/"
load(paste0(cache, "stjude_counts.Rda"))
g <- crosstalkr::prep_biogrid(cache = cache)
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_df <- df
##label the first column as gene name
if(is.character(df[,1])) {
colnames(df)[1] <- "gene_name"
} else if(is.character(rownames(df))) {
df$gene_name <- rownames(df)
}
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
df <- jude_df
##label the first column as gene name
if(is.character(df[,1])) {
colnames(df)[1] <- "gene_name"
} else if(is.character(rownames(df))) {
df$gene_name <- rownames(df)
}
#pivot longer
df <- df %>% tidyr::pivot_longer(-.data$gene_name,
names_to = "sample_name",
values_to = "expression")
df[,1]
is.character(df[,1])
is.character(df[[,1]])
is.character(unlist(df[,1]))
##label the first column as gene name
if(is.character(unlist(df[,1]))) {
colnames(df)[1] <- "gene_name"
} else if(is.character(rownames(df))) {
df$gene_name <- rownames(df)
}
#pivot longer
df <- df %>% tidyr::pivot_longer(-.data$gene_name,
names_to = "sample_name",
values_to = "expression")
#remove rows with zero expression.
#don't want log expression here - negative numbers don't play nice
df <- df %>%
dplyr::mutate(expression = ifelse(.data$expression < 0, 0, .data$expression))
devtools::install()
devtools::install()
devtools::install()
2820000000/ 540000
devtools::install()
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
View(jude_dfnp)
experiment_name = "sj"
ppi = "biogrid"
exp_mat = "jude_df"
mir_paper = FALSE
ncores = 4
if(is.null(cache)) {
stop("please provide a cache for saving and loading data/output")
}
#just return the file if we've already done this
if(file.exists(paste0(cache, experiment_name, "np.Rda"))) {
load(paste0(cache, experiment_name, "np.Rda"))
return(df_np)
}
#load ppi
if(ppi == "biogrid") {
g <- crosstalkr::prep_biogrid(cache = cache)
} else if (ppi == "stringdb") {
g <- crosstalkr::prep_stringdb(cache = cache, min_score = min_score)
} else {
stop("ppi must be either 'biogrid' or 'stringdb'")
}
#convert expression matrix to tidy data frame + do some cleaning
df <- tidy_expression(exp_mat)
exp_mat <- jude_df
#convert expression matrix to tidy data frame + do some cleaning
df <- tidy_expression(exp_mat)
if(mir_paper == TRUE) { #just split up the information in the sample_id
df <- experiment_breakout(df)
}
samples <- unique(df$sample_name)
i <- 1
#isolate one cell line
df_i <- df %>%
dplyr::filter(sample_name == samples[i])
exp <- df_i$expression
names(exp) <- df[[,1]]
df[,1]
names(exp) <- unlist(df[,1]) #this will break if gene name is not the first column
names(exp) <- unlist(df_i[,1])
exp
#calc np for that expression vector- use cpp internal version
np <- calc_np_all(exp, g)
np
devtools::install()
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
install.packages("ellipsis")
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
install.packages("vctrs")
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
View(jude_dfnp)
sum(!is.na(jude_dfnp$np))
147588/16
jdf_dnp <- compute_dnp(cache = cache, df = jude_dfnp, experiment_name = "sj",
ppi = "biogrid", ncores = 5)
View(jude_dfnp)
View(jdf_dnp)
library(devtools)
use_r("compute_null")
use_test()
devtools::load_all()
test <- load_ppi(cache =cache, min_score = NULL, ppi = "biogrid")
df <- jdf_dnp
document()
?compute_null
document()
?compute_null
View(df)
our_samp <- unique(df$sample_name)[1]
df <- dplyr::filter(df, .data$sample_name == our_samp)
document()
document()
document()
check()
check()
#grab list of genes to iterate over
genes <- unique(df$gene_name)
samples <- unique(df$sample_name)
j <-1
df_j <- dplyr::filter(df, .data$sample_name == samples[j])
