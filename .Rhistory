s_new <- s_new[names(s_old)]
s_diff <- s_new-s_old #calculate the diff and save
out_mat[,i] <- s_diff
}
out_mat[,1]
np_diff <- node_repression(g, v_rm = v_check,
state_function = calc_np_all2, exp = toy_exp)
devtools::load_all()
np_diff <- node_repression(g, v_rm = v_check,
state_function = calc_np_all2, exp = toy_exp)
devtools::load_all()
load(system.file("test_data/toy_graph.Rda", package = "disruptr"))
#np_all
seeds <- c("OLR1", "APP", "VAV2", "ITGAV", "JAG1", "APOH")
toy_exp <- c(4.9, 9.9, 1.0, 0.2, 7.5, 8.4)
names(toy_exp) <- seeds
expected_np_old <- c(15.7, -4.8, Inf, -0.94, -2.23, -1.38)
names(expected_np_old) <- seeds
v_check <- seeds[5]
g <- igraph::induced_subgraph(g, seeds)
np_diff <- node_repression(g, v_rm = v_check,
state_function = calc_np_all2, exp = toy_exp)
v_rm = v_check
state_function = calc_np_all2
neigbors_only = TRUE
EXP = TOY_EXP
exp = toy_exp
#grab all vertices of g
vertices <- as.character(names(igraph::V(g)))
#Get a list of neighbors in the graph - this will speed things up a lot if we are suppressing tons of nodes simultaneously
neighbors_all <- lapply(vertices,
get_neighbors, g = g)
names(neighbors_all) <- vertices
out_mat <- Matrix::Matrix(0, nrow = length(igraph::V(g)), ncol = length(v_rm),
sparse = TRUE)
row.names(out_mat) <- vertices
colnames(out_mat) <- v_rm
for(i in 1:length(v_rm)) {
#define v to be either all nodes or neighbors of v_rm
if(neighbors_only == TRUE) {
v <- neighbors_all[[v_rm[i]]] #get neighbors
v <- as.character(names(igraph::V(g)[v]))
} else {
v <- as.character(names(igraph::V(g)))
}
#g_new <- igraph::delete_vertices(g = g, v = v_rm[i])
exp_new <- exp
exp_new[v_rm[i]] <- 0
#calculate state vector for original graph
s_old <- state_function(exp = exp, g = g, v=c(v,v_rm[i]), neighbors = neighbors_all) #calculate network potential for the deleted note in addition to the neighbors
#create a 0 value deleted node to add on
# delete_node <- 0
# names(delete_node) <- v_rm[i]
s_new <- state_function(exp = exp_new, g = g, v = v, neighbors = neighbors_all) #calc new network potential for the neighbors + 0 for the deleted node
s_new <- s_new[names(s_old)]
s_diff <- s_new-s_old #calculate the diff and save
out_mat[,i] <- s_diff
}
neighbors_only = TRUE
for(i in 1:length(v_rm)) {
#define v to be either all nodes or neighbors of v_rm
if(neighbors_only == TRUE) {
v <- neighbors_all[[v_rm[i]]] #get neighbors
v <- as.character(names(igraph::V(g)[v]))
} else {
v <- as.character(names(igraph::V(g)))
}
#g_new <- igraph::delete_vertices(g = g, v = v_rm[i])
exp_new <- exp
exp_new[v_rm[i]] <- 0
#calculate state vector for original graph
s_old <- state_function(exp = exp, g = g, v=c(v,v_rm[i]), neighbors = neighbors_all) #calculate network potential for the deleted note in addition to the neighbors
#create a 0 value deleted node to add on
# delete_node <- 0
# names(delete_node) <- v_rm[i]
s_new <- state_function(exp = exp_new, g = g, v = v, neighbors = neighbors_all) #calc new network potential for the neighbors + 0 for the deleted node
s_new <- s_new[names(s_old)]
s_diff <- s_new-s_old #calculate the diff and save
out_mat[,i] <- s_diff
}
exp
rm(exp)
exp
devtools::load_all()
load(system.file("test_data/toy_graph.Rda", package = "disruptr"))
#np_all
seeds <- c("OLR1", "APP", "VAV2", "ITGAV", "JAG1", "APOH")
toy_exp <- c(4.9, 9.9, 1.0, 0.2, 7.5, 8.4)
names(toy_exp) <- seeds
expected_np_old <- c(15.7, -4.8, Inf, -0.94, -2.23, -1.38)
names(expected_np_old) <- seeds
v_check <- seeds[5]
g <- igraph::induced_subgraph(g, seeds)
np_diff <- node_repression(g, v_rm = v_check, exp = toy_exp
state_function = calc_np_all2)
np_diff <- node_repression(g, v_rm = v_check, exp = toy_exp,
state_function = calc_np_all2)
np_diff
np_diff <- np_diff[,1]
expected_np_diff <- c(0.0, 6.21, 2.23, 0.082, 0.0)
names(expected_np_diff) <- seeds
expected_np_diff <- expected_np_diff[names(np_diff)]
test_that("node_repression produces expected results", {
expect_equal(np_diff,
expected_np_diff, tolerance = 0.1)
})
expected_np_diff
expected_np_diff <- c(0.0, 6.21, 2.23, 0.082, 0.0)
names(expected_np_diff) <- seeds
np_diff
seeds
expected_np_diff <- c(0.0, 6.21, 0.0, 0.082, 2.23, 0.0)
names(expected_np_diff) <- seeds
expected_np_diff <- expected_np_diff[names(np_diff)]
test_that("node_repression produces expected results", {
expect_equal(np_diff,
expected_np_diff, tolerance = 0.1)
})
devtools::test()
devtools::documetn()
devtools::document()
devtools::load_all()
devtools::install()
devtools::install()
devtools::install()
install.packages("dplyr")
install.packages("dplyr")
devtools::install()
source('~/miRNA_targeting/MiR_Analysis_Functions.R')
library(dplyr)
library(tidyr)
library(magrittr)
load('./data_files/final_df.Rda')
cache = "./data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load("./data_files/stjude_counts.Rda")
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
cache = "G:/My Drive/MIR_Combo_Targeting/code/miRNA_Targeting/data_files"
load(paste0(cache, "stjude_counts.Rda"))
cache = "G:/My Drive/MIR_Combo_Targeting/code/miRNA_Targeting/data_files/"
load(paste0(cache, "stjude_counts.Rda"))
g <- crosstalkr::prep_biogrid(cache = cache)
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_df <- df
##label the first column as gene name
if(is.character(df[,1])) {
colnames(df)[1] <- "gene_name"
} else if(is.character(rownames(df))) {
df$gene_name <- rownames(df)
}
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
df <- jude_df
##label the first column as gene name
if(is.character(df[,1])) {
colnames(df)[1] <- "gene_name"
} else if(is.character(rownames(df))) {
df$gene_name <- rownames(df)
}
#pivot longer
df <- df %>% tidyr::pivot_longer(-.data$gene_name,
names_to = "sample_name",
values_to = "expression")
df[,1]
is.character(df[,1])
is.character(df[[,1]])
is.character(unlist(df[,1]))
##label the first column as gene name
if(is.character(unlist(df[,1]))) {
colnames(df)[1] <- "gene_name"
} else if(is.character(rownames(df))) {
df$gene_name <- rownames(df)
}
#pivot longer
df <- df %>% tidyr::pivot_longer(-.data$gene_name,
names_to = "sample_name",
values_to = "expression")
#remove rows with zero expression.
#don't want log expression here - negative numbers don't play nice
df <- df %>%
dplyr::mutate(expression = ifelse(.data$expression < 0, 0, .data$expression))
devtools::install()
devtools::install()
devtools::install()
2820000000/ 540000
devtools::install()
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
View(jude_dfnp)
experiment_name = "sj"
ppi = "biogrid"
exp_mat = "jude_df"
mir_paper = FALSE
ncores = 4
if(is.null(cache)) {
stop("please provide a cache for saving and loading data/output")
}
#just return the file if we've already done this
if(file.exists(paste0(cache, experiment_name, "np.Rda"))) {
load(paste0(cache, experiment_name, "np.Rda"))
return(df_np)
}
#load ppi
if(ppi == "biogrid") {
g <- crosstalkr::prep_biogrid(cache = cache)
} else if (ppi == "stringdb") {
g <- crosstalkr::prep_stringdb(cache = cache, min_score = min_score)
} else {
stop("ppi must be either 'biogrid' or 'stringdb'")
}
#convert expression matrix to tidy data frame + do some cleaning
df <- tidy_expression(exp_mat)
exp_mat <- jude_df
#convert expression matrix to tidy data frame + do some cleaning
df <- tidy_expression(exp_mat)
if(mir_paper == TRUE) { #just split up the information in the sample_id
df <- experiment_breakout(df)
}
samples <- unique(df$sample_name)
i <- 1
#isolate one cell line
df_i <- df %>%
dplyr::filter(sample_name == samples[i])
exp <- df_i$expression
names(exp) <- df[[,1]]
df[,1]
names(exp) <- unlist(df[,1]) #this will break if gene name is not the first column
names(exp) <- unlist(df_i[,1])
exp
#calc np for that expression vector- use cpp internal version
np <- calc_np_all(exp, g)
np
devtools::install()
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
install.packages("ellipsis")
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
install.packages("vctrs")
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
load(paste0(cache, "stjude_counts.Rda"))
jude_df <- jude_df %>% filter(sj_diseases == "EWS")
jude_df <- pivot_wider(jude_df, id_cols = Geneid, names_from = sample_name,
values_from = log_count)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
View(jude_dfnp)
sum(!is.na(jude_dfnp$np))
147588/16
jdf_dnp <- compute_dnp(cache = cache, df = jude_dfnp, experiment_name = "sj",
ppi = "biogrid", ncores = 5)
View(jude_dfnp)
View(jdf_dnp)
library(devtools)
use_r("compute_null")
use_test()
devtools::load_all()
test <- load_ppi(cache =cache, min_score = NULL, ppi = "biogrid")
df <- jdf_dnp
document()
?compute_null
document()
?compute_null
View(df)
our_samp <- unique(df$sample_name)[1]
df <- dplyr::filter(df, .data$sample_name == our_samp)
document()
document()
document()
check()
check()
#grab list of genes to iterate over
genes <- unique(df$gene_name)
samples <- unique(df$sample_name)
j <-1
df_j <- dplyr::filter(df, .data$sample_name == samples[j])
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
jdf_dnp <- compute_dnp(cache = cache, df = jude_dfnp, experiment_name = "sj",
ppi = "biogrid", ncores = 5)
ppi = "biogrid"
n = 10
all_samples == TRUE
all_samples = TRUE
v = NULL
experiment_name = "sj"
ncores = 1
if(is.null(cache)) {
stop("please provide a cache for saving and loading data/output")
}
#just return the file if we've already done this
if(file.exists(paste0(cache, experiment_name, "np.Rda"))) {
load(paste0(cache, experiment_name, "dnpNull.Rda"))
return(df_np)
}
#just return the file if we've already done this
if(file.exists(paste0(cache, experiment_name, "dnpNull.Rda"))) {
load(paste0(cache, experiment_name, "dnpNull.Rda"))
return(df_np)
}
#load ppi
g <- load_ppi(cache = cache, min_score = min_score, ppi = ppi)
#grab the first sample in the data if all_samples== FALSE
if(all_samples == FALSE) {
our_samp <- unique(df$sample_name)[1]
df <- dplyr::filter(df, .data$sample_name == our_samp)
}
#grab list of genes to iterate over and a list of samples to iterate over
genes <- unique(df$gene_name)
samples <- unique(df$sample_name)
df <- jdf_dnp
#grab list of genes to iterate over and a list of samples to iterate over
genes <- unique(df$gene_name)
samples <- unique(df$sample_name)
#do we want to do a grouped split on sample and then iterate directly through the list? probably
df_list <- df %>% dplyr::group_by(.data$sample_name) %>%
dplyr::group_split()
j <- 1
i <- 1
df_j <- df_list[[j]]
#scramble the graph
g_i <- get_random_graph(g)
devtools::load_all()
#scramble the graph
g_i <- get_random_graph(g)
#calc change in network potential
dnp_ij <- calc_dnp_i(df_j, g_i)
#get rid of dnp
df <- df %>% dplyr::select(-dnp)
#do we want to do a grouped split on sample and then iterate directly through the list? probably
df_list <- df %>% dplyr::group_by(.data$sample_name) %>%
dplyr::group_split()
df_j <- df_list[[j]]
#scramble the graph
g_i <- get_random_graph(g)
#calc change in network potential
dnp_ij <- calc_dnp_i(df_j, g_i)
View(dnp_ij)
library(disruptr)
library(dplyr)
library(tidyr)
library(magrittr)
cache = "C:/Users/Install/Documents/miRNA_targeting/data_files/"
g <- crosstalkr::prep_biogrid(cache = cache)
#isolate a single
jude_dfnp <- compute_np(cache = cache, experiment_name = "sj", ppi = "biogrid",
exp_mat= jude_df, mir_paper = FALSE, ncores = 4)
jdf_dnp <- compute_dnp(cache = cache, df = jude_dfnp, experiment_name = "sj",
ppi = "biogrid", ncores = 5)
df = jdf_dnp
n = 10
all_samples = FALSE
experiment_name = "sj"
ncores = 1
if(is.null(cache)) {
stop("please provide a cache for saving and loading data/output")
}
#just return the file if we've already done this
if(file.exists(paste0(cache, experiment_name, "dnpNull.Rda"))) {
load(paste0(cache, experiment_name, "dnpNull.Rda"))
return(df_np)
}
#load ppi
g <- load_ppi(cache = cache, min_score = min_score, ppi = ppi)
#grab the first sample in the data if all_samples== FALSE
if(all_samples == FALSE) {
our_samp <- unique(df$sample_name)[1]
df <- dplyr::filter(df, .data$sample_name == our_samp)
}
#grab list of genes to iterate over and a list of samples to iterate over
genes <- unique(df$gene_name)
samples <- unique(df$sample_name)
all_samples == TRUE
all_samples = TRUE
#grab the first sample in the data if all_samples== FALSE
if(all_samples == FALSE) {
our_samp <- unique(df$sample_name)[1]
df <- dplyr::filter(df, .data$sample_name == our_samp)
}
#grab list of genes to iterate over and a list of samples to iterate over
genes <- unique(df$gene_name)
samples <- unique(df$sample_name)
View(dnp_ij)
object.size(dnp_ij)
?iterators::iter
iterators::iter(df_list)
testiterators::iter(df_list)
test <-
iterators::iter(df_list)
test[1]
test[[]]1
test[[1]]
View(test)
j <- df_j
n = 5
cell_line_df <-
foreach::foreach(i = 1:n, .combine = "rbind", .packages = "disruptr") %do%
{
#scramble the graph
g_i <- get_random_graph(g)
#calc change in network potential
dnp_ij <- calc_dnp_i(j, g_i)
dnp_ij$i = i
}
library(foreach)
cell_line_df <-
foreach::foreach(i = 1:n, .combine = "rbind", .packages = "disruptr") %do%
{
#scramble the graph
g_i <- get_random_graph(g)
#calc change in network potential
dnp_ij <- calc_dnp_i(j, g_i)
dnp_ij$i = i
}
n = 2
cell_line_df <-
foreach::foreach(i = 1:n, .combine = "rbind", .packages = "disruptr") %do%
{
#scramble the graph
g_i <- get_random_graph(g)
#calc change in network potential
dnp_ij <- calc_dnp_i(j, g_i)
dnp_ij$i = i
}
cell_line_df <-
foreach::foreach(i = 1:n, .combine = "rbind", .packages = "disruptr") %do%
{
#scramble the graph
g_i <- get_random_graph(g)
#calc change in network potential
dnp_ij <- calc_dnp_i(j, g_i)
dnp_ij$i = i
return(dnp_ij)
}
n_genes = 50
all_genes = FALSE
View(jude_dfnp)
samples <- unique(df$sample_name)
library(magrittr)
View(jdf_dnp)
df <- jdf_dnp
?slice_max
df_top <- df %>% dplyr::group_by(.data$sample_name) %>%
dplyr::slice_max(order_by = .data$dnp, n = n_genes)
View(df_top)
df_top <- df %>% dplyr::group_by(.data$sample_name) %>%
dplyr::slice_max(order_by = .data$dnp, n = n_genes) %>%
dplyr::select(.data$gene_name, .data$sample_name)
df_top <- df %>% dplyr::group_by(.data$sample_name) %>%
dplyr::slice_max(order_by = .data$dnp, n = n_genes) %>%
dplyr::select(.data$gene_name, .data$sample_name) %>%
dplyr::group_split()
View(df_top)
stringr::str_detect
foreach::foreach()
foreach::foreach
install.packages("randomForest")
randomForest::combine
